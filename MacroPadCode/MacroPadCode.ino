#include <Arduino.h>
#include <Wire.h>
#include <U8g2lib.h>
#include <Adafruit_TinyUSB.h>
#include <Adafruit_NeoPixel.h>
#include <EEPROM.h>

#define GIF_W 32
#define GIF_H 32
#define GIF_FRAMES 12

float currentCursorY = 20;
int targetCursorY = 20;

char trackTitle[80] = "No Media";
char trackArtist[80] = "Disconnected";
int leftViz = 0;
int rightViz = 0;

int currentVolume = 0; // 0-100
int lastKnownVolume = -1;
unsigned long lastVolChangeTime = 0;

String mediaElapsed = "0:00";
String mediaTotal = "0:00";

int timeToSeconds(String t) {
  int colon = t.indexOf(':');
  if (colon == -1) return 0;
  int m = t.substring(0, colon).toInt();
  int s = t.substring(colon + 1).toInt();
  return (m * 60) + s;
}

// 'F18', 32x32px
const unsigned char epd_bitmap_F18 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F19', 32x32px
const unsigned char epd_bitmap_F19 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F20', 32x32px
const unsigned char epd_bitmap_F20 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F21', 32x32px
const unsigned char epd_bitmap_F21 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 
	0x03, 0xc0, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F22', 32x32px
const unsigned char epd_bitmap_F22 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F23', 32x32px
const unsigned char epd_bitmap_F23 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F24', 32x32px
const unsigned char epd_bitmap_F24 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F25', 32x32px
const unsigned char epd_bitmap_F25 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F26', 32x32px
const unsigned char epd_bitmap_F26 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F27', 32x32px
const unsigned char epd_bitmap_F27 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F1', 32x32px
const unsigned char epd_bitmap_F1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F28', 32x32px
const unsigned char epd_bitmap_F28 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F2', 32x32px
const unsigned char epd_bitmap_F2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F3', 32x32px
const unsigned char epd_bitmap_F3 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F4', 32x32px
const unsigned char epd_bitmap_F4 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F5', 32x32px
const unsigned char epd_bitmap_F5 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F6', 32x32px
const unsigned char epd_bitmap_F6 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x0e, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F7', 32x32px
const unsigned char epd_bitmap_F7 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0xf0, 0x00, 0x0f, 0xf1, 0xf0, 
	0x00, 0x0f, 0xe3, 0x60, 0x00, 0x0f, 0xc3, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F8', 32x32px
const unsigned char epd_bitmap_F8 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0xf0, 0x00, 0x0f, 0xfd, 0xf0, 
	0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0xf3, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F9', 32x32px
const unsigned char epd_bitmap_F9 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F10', 32x32px
const unsigned char epd_bitmap_F10 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F11', 32x32px
const unsigned char epd_bitmap_F11 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F12', 32x32px
const unsigned char epd_bitmap_F12 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 
	0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F13', 32x32px
const unsigned char epd_bitmap_F13 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 
	0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F14', 32x32px
const unsigned char epd_bitmap_F14 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F15', 32x32px
const unsigned char epd_bitmap_F15 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F16', 32x32px
const unsigned char epd_bitmap_F16 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F17', 32x32px
const unsigned char epd_bitmap_F17 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


const unsigned char* vortex_all_frames[] = {
	epd_bitmap_F1,
  epd_bitmap_F2,
  epd_bitmap_F3,
  epd_bitmap_F4,
  epd_bitmap_F5,
  epd_bitmap_F6,
  epd_bitmap_F7,
  epd_bitmap_F8,
  epd_bitmap_F9,
  epd_bitmap_F10,
  epd_bitmap_F11,
  epd_bitmap_F12,
  epd_bitmap_F13,
  epd_bitmap_F14,
  epd_bitmap_F15,
  epd_bitmap_F16,
  epd_bitmap_F17,
  epd_bitmap_F18,
  epd_bitmap_F19,
  epd_bitmap_F20,
  epd_bitmap_F21,
  epd_bitmap_F22,
  epd_bitmap_F23,
  epd_bitmap_F24,
  epd_bitmap_F25,
  epd_bitmap_F26,
  epd_bitmap_F27,
  epd_bitmap_F28,
};

const int frameCount = 28;


// ======================================================
// =================== CONFIGURATION ====================
// ======================================================


#define FLASH_SIGNATURE 0x45  // Increment to force reset for new features
#define RGB_PIN 12            // Data Pin for RGB
#define RGB_PWR_PIN 11        // Power Pin for RGB (Must be HIGH)
#define RGB_COUNT 1

// User Status LEDs (Active LOW)
#define LED_RED_PIN   17
#define LED_GREEN_PIN 16
#define LED_BLUE_PIN  25

// Pin Definitions
const int BTN_PINS[4] = { D7, D8, D9, D10 };
const int ENC_A  = D1;
const int ENC_B  = D0;
const int ENC_SW = D2;

// Timing
const unsigned long ENC_HOLD_TIME = 600; // ms
const unsigned long SPLASH_TIME = 2000;
const int MAX_TRAILS = 24;

// Internal codes for Media Keys (Mapped above standard ASCII range)
#define KEY_MEDIA_PLAY    0xF0
#define KEY_MEDIA_NEXT    0xF1
#define KEY_MEDIA_PREV    0xF2
#define KEY_MEDIA_VOL_UP  0xF3
#define KEY_MEDIA_VOL_DN  0xF4
#define KEY_MEDIA_MUTE    0xF5

// ======================================================
// ===================== STRUCTURES =====================
// ======================================================

struct ConfigData {
  uint8_t signature;
  uint8_t keyMapping[4];      // HID Codes
  uint8_t rgbMode;            // 0=Cycle, 1=Custom, 2=Off
  uint8_t rgbR, rgbG, rgbB;   // Custom colors
  uint8_t brightness;         // Global Brightness (0-255)
  uint8_t appMode; // UI Modes
};

ConfigData config;

enum UiState {
  UI_SPLASH,
  UI_HOME,
  UI_SETTINGS_MAIN,
  UI_MODE_SELECT,
  UI_REMAP_WAIT_PRESS,
  UI_REMAP_SELECT_KEY,
  UI_RGB_MODE_SELECT,
  UI_RGB_CUSTOM_MENU,
  UI_RGB_CUSTOM_EDIT,
  UI_BRIGHTNESS
};

UiState uiState = UI_SPLASH;

// ======================================================
// =================== GLOBAL VARS ======================
// ======================================================

// RGB
Adafruit_NeoPixel rgb(RGB_COUNT, RGB_PIN, NEO_GRB + NEO_KHZ800);
uint8_t hueState = 0;

// Display
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// USB HID
uint8_t kb_report[8] = {0}; 
Adafruit_USBD_HID usb_hid;

// Encoder Inputs
bool encClick = false;
bool encHeldTriggered = false; 
bool encPressedState = false;
unsigned long encPressTime = 0;

volatile int encoderPos = 0;
int lastEncoderPos = 0;
int encDir = 0; // -1, 0, 1

// UI Variables
int menuIndex = 0;
int remapTargetBtn = -1;
int remapKeyIndex = 0;
int rgbColorTarget = 0; // 0=R, 1=G, 2=B

// Home Screen Logic
unsigned long lastActivity = 0;
int lastDirIcon = 0;
unsigned long keyTimes[32];
uint8_t keyTimeIdx = 0;

// Modes
enum AppMode { MODE_RHYTHM = 0, MODE_MEDIA = 1 };
AppMode currentAppMode = MODE_RHYTHM;
#define ADDR_APP_MODE 50 // EEPROM address for mode storage

// Media Data Variables
char songTitle[20] = "No Media";
char songArtist[20] = "Disconnected";
int leftLevel = 0;  // 0-8 for visualization
int rightLevel = 0; // 0-8 for visualization

struct Trail {
  bool active;
  int x;
  int y;
  int h;        // Height of the trail
  int btnIndex; // The button this trail belongs to
  bool held;    // Whether the button is still being held
};

Trail trails[MAX_TRAILS];

struct ButtonState {
  bool pressed;
  bool justPressed;
};
ButtonState btnState[4];

// ======================================================
// ==================== KEY TABLES ======================
// ======================================================

struct KeyDef {
  const char* label;
  uint8_t code;
};

const KeyDef keyList[] = {
  // Numbers
  {"0", HID_KEY_0}, {"1", HID_KEY_1}, {"2", HID_KEY_2}, {"3", HID_KEY_3}, {"4", HID_KEY_4},
  {"5", HID_KEY_5}, {"6", HID_KEY_6}, {"7", HID_KEY_7}, {"8", HID_KEY_8}, {"9", HID_KEY_9},
  // Letters
  {"A", HID_KEY_A}, {"B", HID_KEY_B}, {"C", HID_KEY_C}, {"D", HID_KEY_D}, {"E", HID_KEY_E},
  {"F", HID_KEY_F}, {"G", HID_KEY_G}, {"H", HID_KEY_H}, {"I", HID_KEY_I}, {"J", HID_KEY_J},
  {"K", HID_KEY_K}, {"L", HID_KEY_L}, {"M", HID_KEY_M}, {"N", HID_KEY_N}, {"O", HID_KEY_O},
  {"P", HID_KEY_P}, {"Q", HID_KEY_Q}, {"R", HID_KEY_R}, {"S", HID_KEY_S}, {"T", HID_KEY_T},
  {"U", HID_KEY_U}, {"V", HID_KEY_V}, {"W", HID_KEY_W}, {"X", HID_KEY_X}, {"Y", HID_KEY_Y}, {"Z", HID_KEY_Z},
  // Media Keys (New)
  {"PLAY", KEY_MEDIA_PLAY}, {"NEXT", KEY_MEDIA_NEXT}, {"PREV", KEY_MEDIA_PREV},
  {"VOL+", KEY_MEDIA_VOL_UP}, {"VOL-", KEY_MEDIA_VOL_DN}, {"MUTE", KEY_MEDIA_MUTE},
  // Symbols
  {";", HID_KEY_SEMICOLON}, {"=", HID_KEY_EQUAL}, {",", HID_KEY_COMMA}, {"-", HID_KEY_MINUS},
  {".", HID_KEY_PERIOD}, {"/", HID_KEY_SLASH}, {"`", HID_KEY_GRAVE}, {"[", HID_KEY_BRACKET_LEFT},
  {"]", HID_KEY_BRACKET_RIGHT}, {"'", HID_KEY_APOSTROPHE}, {"\\", HID_KEY_BACKSLASH},
  // Functions
  {"F1", HID_KEY_F1}, {"F2", HID_KEY_F2}, {"F3", HID_KEY_F3}, {"F4", HID_KEY_F4},
  {"F5", HID_KEY_F5}, {"F6", HID_KEY_F6}, {"F7", HID_KEY_F7}, {"F8", HID_KEY_F8},
  {"F9", HID_KEY_F9}, {"F10", HID_KEY_F10}, {"F11", HID_KEY_F11}, {"F12", HID_KEY_F12},
  // Special
  {"ESC", HID_KEY_ESCAPE}, {"TAB", HID_KEY_TAB}, {"ENT", HID_KEY_ENTER}, {"SPC", HID_KEY_SPACE},
  {"BSP", HID_KEY_BACKSPACE}, {"DEL", HID_KEY_DELETE}, 
  {"UP", HID_KEY_ARROW_UP}, {"DN", HID_KEY_ARROW_DOWN}, {"LF", HID_KEY_ARROW_LEFT}, {"RT", HID_KEY_ARROW_RIGHT},
  {"CAPS", HID_KEY_CAPS_LOCK}, {"PRT", HID_KEY_PRINT_SCREEN},
  {"LCTL", HID_KEY_CONTROL_LEFT}, {"LSFT", HID_KEY_SHIFT_LEFT}, {"LALT", HID_KEY_ALT_LEFT}, {"LGUI", HID_KEY_GUI_LEFT}
};
const int KEY_LIST_LEN = sizeof(keyList) / sizeof(keyList[0]);

const char* getLabel(uint8_t code) {
  for(int i=0; i<KEY_LIST_LEN; i++) {
    if(keyList[i].code == code) return keyList[i].label;
  }
  return "?";
}

// ======================================================
// ======================= LOGO =========================
// ======================================================
const unsigned char epd_bitmap_vortex_no_text [] PROGMEM = {
  0xf0,0x00,0x00,0xe0,0x00,0x00,0xe0,0x00,0x00,0x1d,0x80,0x00,
  0x1d,0x80,0x00,0x1d,0xbe,0x60,0x01,0xbe,0xa0,0x01,0xbd,0x00,
  0x01,0x80,0x40,0x01,0x82,0x80,0x01,0x85,0x00,0x01,0x8e,0x00,
  0x01,0x8e,0x00,0x01,0x9c,0x00,0x01,0xb8,0x00,0x01,0xf8,0x00,
  0x01,0xf0,0x00,0x01,0xe0,0x00,0x01,0xc0,0x00,0x01,0xc0,0x00
};
#define LOGO_W 20
#define LOGO_H 20

static inline uint8_t bitrev(uint8_t b){
  b = (b >> 4) | (b << 4);
  b = ((b & 0xCC) >> 2) | ((b & 0x33) << 2);
  b = ((b & 0xAA) >> 1) | ((b & 0x55) << 1);
  return b;
}
void drawBitmap(int x, int y, const uint8_t* src) {
  uint8_t buf[60]; 
  for(int i=0; i<60; i++) buf[i] = bitrev(pgm_read_byte(&src[i]));
  u8g2.drawXBMP(x, y, LOGO_W, LOGO_H, buf);
}

void drawLogoBitmap(int x, int y, const uint8_t* src) {
  uint8_t buf[128]; 
  for(int i=0; i<128; i++) buf[i] = bitrev(pgm_read_byte(&src[i]));
  u8g2.drawXBMP(x, y, 32, 32, buf);
}


// ======================================================
// ===================== SAVE/LOAD ======================
// ======================================================
void saveConfig() {
  EEPROM.put(0, config);
  EEPROM.commit();
}
void loadConfig() {
  EEPROM.begin(256);
  EEPROM.get(0, config);
  if (config.signature != FLASH_SIGNATURE) {
    config.signature = FLASH_SIGNATURE;
    config.keyMapping[0] = HID_KEY_A;
    config.keyMapping[1] = HID_KEY_S;
    config.keyMapping[2] = HID_KEY_L;
    config.keyMapping[3] = HID_KEY_SEMICOLON;
    config.rgbMode = 0; 
    config.rgbR = 0; config.rgbG = 255; config.rgbB = 255;
    config.brightness = 150;
    saveConfig();
  }
  EEPROM.get(ADDR_APP_MODE, currentAppMode);
  if(currentAppMode > 1) currentAppMode = MODE_RHYTHM;
}

// ======================================================
// ==================== USB / HID =======================
// ======================================================

uint8_t const hid_report_descriptor[] = {
  TUD_HID_REPORT_DESC_KEYBOARD(HID_REPORT_ID(1)),
  TUD_HID_REPORT_DESC_CONSUMER(HID_REPORT_ID(2))
};

void setupHID() {
  usb_hid.setPollInterval(2);
  usb_hid.setReportDescriptor(hid_report_descriptor, sizeof(hid_report_descriptor));
  usb_hid.begin();
}

void sendMediaRaw(uint16_t key) {
  if (!usb_hid.ready()) return;
  usb_hid.sendReport(2, &key, 2);
}

// Modified HID Update to handle Keyboard AND Media keys simultaneously
void updateHID() {
  if (!usb_hid.ready()) return;

  // 1. Create a fresh, empty keyboard report
  uint8_t current_kb_report[8] = {0, 0, 0, 0, 0, 0, 0, 0}; 
  uint16_t media_usage = 0;
  int kb_slot = 2; 

  // 2. Scan physical button states
  for(int i = 0; i < 4; i++) {
    if (btnState[i].pressed) {
      uint8_t code;

      // --- NEW MEDIA MODE OVERRIDE ---
      // If we are in Media Mode (1) and on the Home Screen, force media behavior
      if (config.appMode == 1 && uiState == UI_HOME) {
        if (i == 0) media_usage = HID_USAGE_CONSUMER_SCAN_PREVIOUS_TRACK;
        if (i == 1) media_usage = HID_USAGE_CONSUMER_PLAY_PAUSE;
        if (i == 2) media_usage = HID_USAGE_CONSUMER_MUTE;
        if (i == 3) media_usage = HID_USAGE_CONSUMER_SCAN_NEXT_TRACK;
        continue; // Skip the standard mapping logic for this button
      } 
      
      // --- STANDARD MAPPING LOGIC ---
      code = config.keyMapping[i];
      
      // Separate Media Keys from Keyboard Keys
      if (code >= 0xF0) {
        if (code == KEY_MEDIA_PLAY)   media_usage = HID_USAGE_CONSUMER_PLAY_PAUSE;
        if (code == KEY_MEDIA_NEXT)   media_usage = HID_USAGE_CONSUMER_SCAN_NEXT_TRACK;
        if (code == KEY_MEDIA_PREV)   media_usage = HID_USAGE_CONSUMER_SCAN_PREVIOUS_TRACK;
        if (code == KEY_MEDIA_VOL_UP) media_usage = HID_USAGE_CONSUMER_VOLUME_INCREMENT;
        if (code == KEY_MEDIA_VOL_DN) media_usage = HID_USAGE_CONSUMER_VOLUME_DECREMENT;
        if (code == KEY_MEDIA_MUTE)   media_usage = HID_USAGE_CONSUMER_MUTE;
      } 
      else {
        // Standard Key
        if (kb_slot < 8) {
          current_kb_report[kb_slot] = code;
          kb_slot++;
        }
      }
    }
  }

  // 3. Compare with the LAST sent report to prevent USB flooding
  static uint8_t last_kb_report[8] = {0};
  if (memcmp(current_kb_report, last_kb_report, 8) != 0) {
    usb_hid.sendReport(1, current_kb_report, 8);
    memcpy(last_kb_report, current_kb_report, 8);
  }
  
  // 4. Handle Media Keys (Consumer Report)
  static uint16_t last_media_usage = 0;
  if (media_usage != last_media_usage) {
    usb_hid.sendReport(2, &media_usage, 2);
    last_media_usage = media_usage;
  }
}

// ======================================================
// ================== STATUS LEDS =======================
// ======================================================
void updateStatusLED() {
  // Reset all to OFF (HIGH)
  digitalWrite(LED_RED_PIN, HIGH);
  digitalWrite(LED_GREEN_PIN, HIGH);
  digitalWrite(LED_BLUE_PIN, HIGH);

  if (uiState != UI_HOME && uiState != UI_SPLASH) {
    // Blue: Settings Mode
    digitalWrite(LED_BLUE_PIN, LOW);
  } else if (!TinyUSBDevice.mounted()) {
    // Red: Disconnected
    digitalWrite(LED_RED_PIN, LOW);
  } else {
    // Green: Connected & Home
    digitalWrite(LED_GREEN_PIN, LOW);
  }
}

// ======================================================
// ===================== RGB LOGIC ======================
// ======================================================

void updateRGB() {
  rgb.setBrightness(config.brightness);
  
  if (config.rgbMode == 2) { // OFF
    rgb.clear();
  } 
  else if (config.rgbMode == 0) { // CYCLE
    rgb.setPixelColor(0, rgb.ColorHSV(hueState++ * 256));
    if (hueState > 255) hueState = 0;
  } 
  else if (config.rgbMode == 1) { // CUSTOM
    rgb.setPixelColor(0, rgb.Color(config.rgbR, config.rgbG, config.rgbB));
  }
  rgb.show();
}

// ======================================================
// ===================== INPUTS =========================
// ======================================================

void encoderISR() {
  uint8_t state = (digitalRead(ENC_A) << 1) | digitalRead(ENC_B);
  static uint8_t oldState = 0;
  static const int8_t tbl[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};
  encoderPos -= tbl[(oldState << 2) | state];
  oldState = state;
}

void readInputs() {
  // 1. Encoder Button
  bool sw = !digitalRead(ENC_SW);
  unsigned long now = millis();

  if (sw) { // Button is DOWN
    if (!encPressedState) {
      encPressedState = true;
      encPressTime = now;
      encHeldTriggered = false; 
    } else {
      if (!encHeldTriggered && (now - encPressTime > ENC_HOLD_TIME)) {
        encHeldTriggered = true; 
        
        // Hold Action
        if (uiState == UI_HOME) {
          uiState = UI_SETTINGS_MAIN;
          menuIndex = 0;
        } else if (uiState != UI_SPLASH) {
          uiState = UI_HOME; // Exit settings
        }
      }
    }
  } else { // Button is UP
    if (encPressedState) {
      encPressedState = false;
      if (!encHeldTriggered) {
        encClick = true;
      }
    }
  }

  // 2. Encoder Rotation
  int newPos = encoderPos / 4; 
  encDir = 0;
  if (newPos != lastEncoderPos) {
    encDir = (newPos > lastEncoderPos) ? 1 : -1;
    lastEncoderPos = newPos;
    
    // Global Volume Control (Only on Home)
    if (uiState == UI_HOME) {
      uint16_t v = encDir > 0 ? HID_USAGE_CONSUMER_VOLUME_INCREMENT : HID_USAGE_CONSUMER_VOLUME_DECREMENT;
      usb_hid.sendReport(2, &v, 2);
      delay(5);
      uint16_t z = 0;
      usb_hid.sendReport(2, &z, 2);

      lastActivity = now;
      lastDirIcon = encDir;
    }
  }

  // 3. Keys
  for(int i=0; i<4; i++) {
    bool p = !digitalRead(BTN_PINS[i]);
    btnState[i].justPressed = (p && !btnState[i].pressed);
    btnState[i].pressed = p;

    // KPS Logic
    if (btnState[i].justPressed && uiState == UI_HOME) {
      keyTimes[keyTimeIdx++ % 32] = millis();
      for(int t=0; t<MAX_TRAILS; t++) {
        if(!trails[t].active) {
          // {active, x, y, h, btnIndex, held}
          // Start at y=46 with height h=2
          trails[t] = {true, 48 + (i*20), 46, 2, i, true};
          break;
        }
      }
    }
  }
}

// ======================================================
// ======================= LOGIC ========================
// ======================================================

float getKPS() {
  unsigned long now = millis();
  int count = 0;
  for(int i=0; i<32; i++) {
    if (now - keyTimes[i] < 1000) count++;
  }
  return (float)count;
}

void scroll(int &val, int min, int max, int dir) {
  if (dir == 0) return;
  val += dir;
  if (val > max) val = min;
  if (val < min) val = max;
}

void handleStateMachine() {
  // Navigation Inversion: 
  // Clockwise (+1) becomes -1 (Up in lists)
  // Counter-Clockwise (-1) becomes +1 (Down in lists)
  int menuDir = -encDir; 

  switch (uiState) {
    case UI_HOME:
      if (encClick) {
        uint16_t pp = HID_USAGE_CONSUMER_PLAY_PAUSE;
        usb_hid.sendReport(2, &pp, 2);
        delay(5);
        uint16_t z = 0;
        usb_hid.sendReport(2, &z, 2);
        encClick = false;
      }
      break;

    case UI_MODE_SELECT:
      scroll(menuIndex, 0, 1, menuDir);
      if (encClick) {
        encClick = false;
        config.appMode = menuIndex;
        saveConfig();
        uiState = UI_SETTINGS_MAIN;
        menuIndex = 0; // Reset for settings menu
      }
      break;

  case UI_SETTINGS_MAIN:
    scroll(menuIndex, 0, 3, -menuDir); // Index 0 to 3
    if (encClick) {
      encClick = false;
      if (menuIndex == 0) { uiState = UI_MODE_SELECT; menuIndex = config.appMode; }
      else if (menuIndex == 1) { uiState = UI_REMAP_WAIT_PRESS; }
      else if (menuIndex == 2) { uiState = UI_RGB_MODE_SELECT; menuIndex = config.rgbMode; }
      else if (menuIndex == 3) { uiState = UI_BRIGHTNESS; }
    }
    break;



    case UI_REMAP_WAIT_PRESS:
      for(int i=0; i<4; i++) {
        if(btnState[i].justPressed) {
          remapTargetBtn = i;
          uiState = UI_REMAP_SELECT_KEY;
          remapKeyIndex = 0;
          break;
        }
      }
      if (encClick) { encClick=false; uiState = UI_SETTINGS_MAIN; }
      break;

    case UI_REMAP_SELECT_KEY:
      // INVERTED: Clockwise now moves UP through the key list
      scroll(remapKeyIndex, 0, KEY_LIST_LEN-1, menuDir); 
      if (encClick) {
        encClick = false;
        config.keyMapping[remapTargetBtn] = keyList[remapKeyIndex].code;
        saveConfig();
        uiState = UI_SETTINGS_MAIN;
      }
      break;

    case UI_RGB_MODE_SELECT:
      scroll(menuIndex, 0, 2, menuDir); 
      if (encClick) {
        encClick = false;
        config.rgbMode = menuIndex;
        saveConfig();
        if (config.rgbMode == 1) { 
          uiState = UI_RGB_CUSTOM_MENU;
          rgbColorTarget = 0;
        } else {
          uiState = UI_SETTINGS_MAIN;
        }
      }
      break;

    case UI_RGB_CUSTOM_MENU:
      scroll(rgbColorTarget, 0, 2, menuDir); 
      if (encClick) {
        encClick = false;
        uiState = UI_RGB_CUSTOM_EDIT;
      }
      break;

    case UI_RGB_CUSTOM_EDIT:
      // Keep encDir: CW = Increase color value
      if (encDir != 0) {
        int val = (rgbColorTarget==0)?config.rgbR : (rgbColorTarget==1)?config.rgbG : config.rgbB;
        val = constrain(val + (encDir * 5), 0, 255);
        if (rgbColorTarget == 0) config.rgbR = val;
        if (rgbColorTarget == 1) config.rgbG = val;
        if (rgbColorTarget == 2) config.rgbB = val;
        updateRGB();
      }
      if (encClick) {
        encClick = false;
        saveConfig();
        uiState = UI_RGB_CUSTOM_MENU;
      }
      break;
    
    case UI_BRIGHTNESS:
      // Keep encDir: CW = Brighter
      if (encDir != 0) {
        int b = config.brightness + (encDir * 5);
        config.brightness = constrain(b, 5, 255);
        updateRGB(); 
      }
      if (encClick) {
        encClick = false;
        saveConfig();
        uiState = UI_SETTINGS_MAIN;
      }
      break;
  }
}
// ======================================================
// ==================== DRAWING =========================
// ======================================================

void drawDetailPanel() {
  drawBitmap(10, 0, epd_bitmap_vortex_no_text); 

  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(12, 35); u8g2.print("KPS");
  u8g2.setFont(u8g2_font_profont17_tf);
  u8g2.setCursor(12, 50); u8g2.print((int)getKPS());

  if (millis() - lastActivity < 1000) {
     u8g2.setFont(u8g2_font_ncenB18_tr);
     u8g2.setCursor(12, 64);
     u8g2.print(lastDirIcon > 0 ? "+" : "-");
  }
  
  u8g2.drawVLine(40, 0, 64);
}

void drawTrails() {
  for(int i=0; i<MAX_TRAILS; i++) {
    if (!trails[i].active) continue;
    
    u8g2.drawBox(trails[i].x, trails[i].y, 16, trails[i].h);
    
    if (!trails[i].held) {
      // Falling/Floating away logic
      trails[i].y -= 3; // Speed it up slightly
      if (trails[i].y + trails[i].h < 0) trails[i].active = false;
    } else {
      // Check if button was released
      if (!btnState[trails[i].btnIndex].pressed) {
        trails[i].held = false;
      } else {
        // Grow logic while held
        if (trails[i].h < 40) { // Increased max height to 40
             trails[i].h += 3; // Grow 3x faster than before
             trails[i].y -= 3; // Move top up to match growth
        }
      }
    }
  }
}

void drawHome() {
  drawDetailPanel();
  drawTrails();

  u8g2.setFont(u8g2_font_profont12_tf);
  for(int i=0; i<4; i++) {
    int x = 48 + (i * 20);
    int y = 48;
    if (btnState[i].pressed) u8g2.drawBox(x, y, 16, 16);
    else u8g2.drawFrame(x, y, 16, 16);

    u8g2.setCursor(x + 5, y + 11);
    if (btnState[i].pressed) u8g2.setDrawColor(0);
    u8g2.print(getLabel(config.keyMapping[i]));
    u8g2.setDrawColor(1);
  }
}

void drawMediaMode() {
  u8g2.setFont(u8g2_font_5x7_tr);
  
  // Draw Curved Visualizers (Head unit style)
  for(int i=0; i<leftLevel; i++) {
    u8g2.drawRFrame(2, 45 - (i*5), 8, 3, 1); // Left stack
  }
  for(int i=0; i<rightLevel; i++) {
    u8g2.drawRFrame(118, 45 - (i*5), 8, 3, 1); // Right stack
  }

  // Song Info
  u8g2.setFont(u8g2_font_7x14_tr);
  u8g2.drawStr(20, 15, songTitle);
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(20, 28, songArtist);

  // Bottom Button Labels (Prev | Play/Pause | Mute | Next)
  u8g2.drawHLine(0, 52, 128);
  u8g2.drawStr(5, 62, "PRV");
  u8g2.drawStr(40, 62, "P/P");
  u8g2.drawStr(75, 62, "MUTE");
  u8g2.drawStr(105, 62, "NXT");
}

float smoothMenuY = 26.0; // Starting position for the settings cursor

void drawSettings() {
  u8g2.setFont(u8g2_font_profont12_tf); // CRITICAL: Reset font to text
  drawBitmap(0, 0, epd_bitmap_vortex_no_text); 
  u8g2.setCursor(30, 15); 
  u8g2.print("SETTINGS");
  u8g2.drawHLine(0, 22, 128);


  const char* items[] = {"Mode Select", "Remap Keys", "RGB Setup", "Brightness"};
  int total = 4;
  int visible = 3;
  int yStart = 32; // Adjusted to align with header line
  // Calculate which item is at the top of the screen
  int top = (menuIndex >= visible) ? (menuIndex - (visible - 1)) : 0;

  // 2. Draw Menu Text (Always in Draw Color 1)
  u8g2.setDrawColor(1);
  for (int i = 0; i < visible; i++) {
    int idx = i + top;
    if (idx < total) {
      u8g2.setCursor(10, yStart + (i * 12));
      u8g2.print(items[idx]);
    }
  }

  // 3. Animation Logic
  // Calculate target Y based on relative position (menuIndex - top)
  float targetY = yStart + ((menuIndex - top) * 12) - 9;
  
  // Smoothly move the global smoothMenuY toward targetY
  smoothMenuY += (targetY - smoothMenuY) * 0.25; 

  // 4. Draw Sliding XOR Box
  // This makes the text "flip" colors when the box slides over it
  u8g2.setDrawColor(2); 
  u8g2.drawBox(0, (int)smoothMenuY, 128, 11);
  u8g2.setDrawColor(1); // Reset draw color to normal
}

bool mirroringMode = false;

void handleMirroring() {
  if (Serial.available() > 0) {
    // Look for a start byte (e.g., 0x02 for 'Start of Text')
    if (Serial.read() == 0x02) {
      mirroringMode = true;
      uint8_t buffer[1024]; // Adjust based on your screen size (128x64 / 8 = 1024 bytes)
      Serial.readBytes(buffer, 1024);
      
      u8g2.clearBuffer();
      u8g2.drawBitmap(0, 0, 16, 64, buffer); // 16 bytes wide = 128 pixels
      u8g2.sendBuffer();
    }
  }
  
  // Exit mirroring if the encoder is clicked
  if (encClick) {
    mirroringMode = false;
    encClick = false;
  }
}

void drawModeSelect() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.drawStr(5, 12, "SELECT MODE");
  u8g2.drawHLine(0, 15, 128);

  const char* modes[] = {"Rhythm", "Media Control"};
  for (int i = 0; i < 2; i++) {
    u8g2.setCursor(15, 32 + (i * 15));
    if (menuIndex == i) u8g2.print("> ");
    u8g2.print(modes[i]);
  }
}


void drawVolumeOverlay() {
  // 1. Set font to 2x (16px tall). 
  // If this is still too big, use 1x (8px tall)
  u8g2.setFont(u8g2_font_open_iconic_play_2x_t); 
  
  // 2. Assign the correct icon based on your requirement
  int iconChar;
  if (currentVolume > 66) {
    iconChar = 0x4F; // Stage 1: Loud
  } else if (currentVolume > 33) {
    iconChar = 0x50; // Stage 2: Mid
  } else {
    iconChar = 0x51; // Stage 3: Low/Mute
  }

  // 3. Draw Icon (Centered X=56, Y=30)
  u8g2.drawGlyph(56, 30, iconChar);

  // 4. Draw Volume Text below it
  u8g2.setFont(u8g2_font_profont12_tf);
  
  char volStr[20];
  sprintf(volStr, "Volume: %d%%", currentVolume);
  
  int strWidth = u8g2.getStrWidth(volStr);
  int xPos = (128 - strWidth) / 2; // Center the text string
  
  // Place text at Y=50 (20 pixels below the icon)
  u8g2.setCursor(xPos, 40);
  u8g2.print(volStr);
}

int titleScrollX = 0;
unsigned long lastScrollTime = 0;
const int scrollSpeed = 30;   // lower = faster (ms per step)
const int textAreaWidth = 80; // reduce width by 4px total (2px each side)


void drawMediaHome() {
  u8g2.setDrawColor(1);

  // 1. Far-Edge Visualizers
  for (int i = 0; i < 8; i++) {
    int y = 40 - (i * 5);
    int curve = abs(4 - i);
    if (i < leftViz)  u8g2.drawBox(2 + curve, y, 5, 3);
    if (i < rightViz) u8g2.drawBox(121 - curve, y, 5, 3);
  }

  // 2. Icon Labels (Bottom)
  u8g2.setFont(u8g2_font_open_iconic_play_1x_t);
  u8g2.drawGlyph(15, 64, 0x0049);
  u8g2.drawGlyph(47, 64, 0x0045);
  u8g2.drawGlyph(78, 64, 0x004F);
  u8g2.drawGlyph(108, 64, 0x004A);

  // Volume Popup
  if (millis() - lastVolChangeTime < 1000) {
    drawVolumeOverlay();
    return;
  }

  // ===============================
  // 3. TRACK TITLE (CLIPPED SCROLL)
  // ===============================
  u8g2.setFont(u8g2_font_profont12_tf);

  const int LEFT_BOUND  = 18;
  const int RIGHT_BOUND = 110;
  const int TEXT_WIDTH  = RIGHT_BOUND - LEFT_BOUND;

  int textWidth = u8g2.getStrWidth(trackTitle);
  int textY_Title = 15;

  // Enable clipping region
  u8g2.setClipWindow(LEFT_BOUND, 0, RIGHT_BOUND, 20);

  if (textWidth > TEXT_WIDTH) {

    if (millis() - lastScrollTime > scrollSpeed) {
      titleScrollX--;
      if (titleScrollX < -textWidth)
        titleScrollX = TEXT_WIDTH;
      lastScrollTime = millis();
    }

    u8g2.drawStr(LEFT_BOUND + titleScrollX, textY_Title, trackTitle);

  } else {
    int centeredX = LEFT_BOUND + (TEXT_WIDTH - textWidth) / 2;
    u8g2.drawStr(centeredX, textY_Title, trackTitle);
    titleScrollX = 0;
  }

  // Disable clipping
  u8g2.setMaxClipWindow();


  // ===============================
  // 4. ARTIST
  // ===============================
  u8g2.setFont(u8g2_font_4x6_tr);
  int artistWidth = u8g2.getStrWidth(trackArtist);
  u8g2.drawStr(64 - (artistWidth / 2), 25, trackArtist);

  // ===============================
  // 5. PROGRESS BAR + TIMES
  // ===============================
  int curSec = timeToSeconds(mediaElapsed);
  int totSec = timeToSeconds(mediaTotal);
  float progress = (totSec > 0) ? (float)curSec / (float)totSec : 0.0;
  if (progress > 1.0) progress = 1.0;

  int totWidth = u8g2.getStrWidth(mediaTotal.c_str());
  int elapsedWidth = u8g2.getStrWidth(mediaElapsed.c_str());

  int barX = elapsedWidth + 4;
  int barW_Total = (128 - totWidth) - barX - 4;
  int barH = 6;
  int barY = 32;

  int textY_Time = barY + barH + 8;

  u8g2.setCursor(barX, textY_Time);
  u8g2.print(mediaElapsed);

  u8g2.setCursor(barX + barW_Total - totWidth, textY_Time);
  u8g2.print(mediaTotal);

  u8g2.drawFrame(barX, barY, barW_Total, barH);

  if (barW_Total > 2) {
    int fillW = (int)((barW_Total - 4) * progress);
    if (fillW > 0) {
      u8g2.drawBox(barX + 2, barY + 2, fillW, barH - 4);
    }
  }
}


void drawRemap() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(10, 15);
  if (uiState == UI_REMAP_WAIT_PRESS) {
    u8g2.print("Press key to remap"); // Text Changed
    // --- ADD THIS SECTION TO SHOW CURRENT KEYS ---
    u8g2.drawHLine(0, 48, 128); // Optional separator line
    for(int i=0; i<4; i++) {
      int x = 10 + (i * 30); // Spacing for 4 keys
      u8g2.setCursor(x, 60);
      u8g2.print(getLabel(config.keyMapping[i])); 
    }
    // ----------------------------------------------
  } else {
    u8g2.print("Select Key:");
    u8g2.setFont(u8g2_font_ncenB14_tr);
    u8g2.setCursor(50, 45);
    u8g2.print(keyList[remapKeyIndex].label);
    
    u8g2.setFont(u8g2_font_profont10_tf);
    int prev = (remapKeyIndex - 1 + KEY_LIST_LEN) % KEY_LIST_LEN;
    int next = (remapKeyIndex + 1) % KEY_LIST_LEN;
    u8g2.setCursor(50, 25); u8g2.print(keyList[prev].label);
    u8g2.setCursor(50, 60); u8g2.print(keyList[next].label);
  }
}

void drawRGBCustom() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(5, 12); u8g2.print("RGB CUSTOM");
  
  int bars[3] = {config.rgbR, config.rgbG, config.rgbB};
  const char* lbls[3] = {"R", "G", "B"};
  
  for(int i=0; i<3; i++) {
    int y = 28 + (i*12);
    u8g2.setCursor(5, y); u8g2.print(lbls[i]);
    u8g2.setCursor(20, y); u8g2.print(bars[i]);

    u8g2.drawFrame(45, y-8, 80, 8);
    int w = map(bars[i], 0, 255, 0, 78);
    u8g2.drawBox(46, y-7, w, 6);

    if (i == rgbColorTarget) {
      u8g2.setCursor(128, y);
      if (uiState == UI_RGB_CUSTOM_EDIT) u8g2.drawStr(120, y, "<");
      else u8g2.drawStr(120, y, "*");
    }
  }
}

void drawBrightness() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(10, 20); u8g2.print("BRIGHTNESS");
  
  u8g2.setCursor(10, 40); u8g2.print(config.brightness);
  
  u8g2.drawFrame(40, 32, 80, 10);
  int w = map(config.brightness, 0, 255, 0, 78);
  u8g2.drawBox(41, 33, w, 8);
}

void drawSplash() {
  static int currentFrame = 0;
  static unsigned long lastFrameTime = 0;
  static unsigned long splashStartTime = 0;
  unsigned long now = millis();

  if (splashStartTime == 0) splashStartTime = now;

  const uint8_t* framePtr = vortex_all_frames[currentFrame];

  u8g2.clearBuffer();
  
  // Use the updated function with 32x32 dimensions
  drawLogoBitmap(48, 16, framePtr);
  
  u8g2.sendBuffer();
  if (now - lastFrameTime >= 40) {
      // Only increment if we haven't reached the last frame (frameCount - 1)
      if (currentFrame < frameCount - 1) {
        currentFrame++;
      }
      lastFrameTime = now;
    }

  if (now - splashStartTime > 2500) {
    uiState = UI_HOME;
    currentFrame = 0;
    splashStartTime = 0;
  }
}
// ======================================================
// ==================== MAIN LOOP =======================
// ======================================================

void setup() {
  for(int i=0; i<4; i++) pinMode(BTN_PINS[i], INPUT_PULLUP);
  pinMode(ENC_A, INPUT_PULLUP);
  pinMode(ENC_B, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);
  
  // Status LEDs (Active Low)
  pinMode(LED_RED_PIN, OUTPUT);
  pinMode(LED_GREEN_PIN, OUTPUT);
  pinMode(LED_BLUE_PIN, OUTPUT);
  digitalWrite(LED_RED_PIN, HIGH);
  digitalWrite(LED_GREEN_PIN, HIGH);
  digitalWrite(LED_BLUE_PIN, HIGH);
  
  attachInterrupt(digitalPinToInterrupt(ENC_A), encoderISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_B), encoderISR, CHANGE);

  // RGB POWER FIX
  pinMode(RGB_PWR_PIN, OUTPUT);
  digitalWrite(RGB_PWR_PIN, HIGH);

  rgb.begin();
  
  loadConfig();
  rgb.setBrightness(config.brightness);
  
  setupHID();
  u8g2.begin();
  lastKnownVolume = currentVolume;
}

unsigned long lastMirrorFrame = 0; // Track when we last got a frame
const int mirrorTimeout = 500;    // How long to stay in mirror mode (ms)

void loop() {
  // 1. Check for incoming Serial Data
  if (Serial.available() > 0) {
    
    // Peek to see if it is an Image (0x02) or Text
    int firstByte = Serial.peek();

    if (firstByte == 0x02) {
      // --- IMAGE MODE (Mirroring) ---
      Serial.read(); // Consume the 0x02 header
      
      uint8_t buffer[1024];
      Serial.setTimeout(50); 
      size_t readCount = Serial.readBytes(buffer, 1024);
      
      if (readCount == 1024) {
        u8g2.clearBuffer();
        u8g2.drawBitmap(0, 0, 16, 64, buffer); // Draw the bitmap
        u8g2.sendBuffer();
        
        Serial.write(0x06); // ACK
        lastMirrorFrame = millis(); // Mark time so local UI doesn't overwrite immediately
      } else {
        Serial.write(0x06); // ACK anyway to keep stream moving
      }
      return; // Stop here, don't draw local UI this cycle
    } 
    else {
      // --- TEXT MODE (Metadata) ---
      String command = Serial.readStringUntil('\n');
      command.trim(); // Important: Removes \r or extra spaces

      if (command == "IDENTIFY") {
        Serial.println("MACROPAD_STATION");
      } 
      else if (command.startsWith("MET:")) {
        command.remove(0, 4); // Remove "MET:"
        
        int p1 = command.indexOf('|');
        int p2 = command.indexOf('|', p1 + 1);
        int p3 = command.indexOf('|', p2 + 1);
        int p4 = command.indexOf('|', p3 + 1);
        int p5 = command.indexOf('|', p4 + 1);
        int p6 = command.indexOf('|', p5 + 1);

        if (p6 != -1) {
          // Parse Strings
          String t = command.substring(0, p1);
          String a = command.substring(p1 + 1, p2);
          
          t.toCharArray(trackTitle, sizeof(trackTitle));
          a.toCharArray(trackArtist, sizeof(trackArtist));

          
          // Parse Visuals
          leftViz = command.substring(p2 + 1, p3).toInt();
          rightViz = command.substring(p3 + 1, p4).toInt();
          
          // Parse Volume
          int newVol = command.substring(p4 + 1, p5).toInt();
          
          if (newVol != lastKnownVolume) {
            lastVolChangeTime = millis();
            lastKnownVolume = newVol;
          }
          currentVolume = newVol;

          // Parse Times
          mediaElapsed = command.substring(p5 + 1, p6);
          mediaTotal = command.substring(p6 + 1);
        }
      }
    }
  } // End of Serial Check

  // 2. Local UI Logic
  // If we recently received a mirror frame (last 500ms), don't draw local UI
  if (millis() - lastMirrorFrame < 500) {
    return;
  }

  readInputs();
  handleStateMachine();
  updateRGB(); 
  updateStatusLED();
  updateHID();

  // Draw Splash if active
  if (uiState == UI_SPLASH) {
    drawSplash();
    return;
  }

  // Draw Main UI
  u8g2.clearBuffer();
  
  switch(uiState) {
    case UI_HOME:            
      if (config.appMode == 1) drawMediaHome(); // Show Media UI
      else drawHome();                          // Show Rhythm UI
      break;
    case UI_SETTINGS_MAIN:   drawSettings(); break;
    case UI_REMAP_WAIT_PRESS:
    case UI_REMAP_SELECT_KEY:drawRemap(); break;
    case UI_RGB_MODE_SELECT: 
      u8g2.setFont(u8g2_font_profont12_tf);
      u8g2.setCursor(10, 20); u8g2.print("RGB MODE:");
      u8g2.setFont(u8g2_font_ncenB14_tr);
      u8g2.setCursor(20, 45); 
      if(menuIndex==0) u8g2.print("CYCLE");
      if(menuIndex==1) u8g2.print("CUSTOM");
      if(menuIndex==2) u8g2.print("OFF");
      break;
    case UI_RGB_CUSTOM_MENU:
    case UI_RGB_CUSTOM_EDIT: drawRGBCustom(); break;
    case UI_BRIGHTNESS:      drawBrightness(); break;
    case UI_MODE_SELECT:     drawModeSelect(); break; 
  }
  
  u8g2.sendBuffer();

} // <--- CORRECT End of loop()