#include <Arduino.h>
#include <Wire.h>
#include <U8g2lib.h>
#include <Adafruit_TinyUSB.h>
#include <Adafruit_NeoPixel.h>
#include <EEPROM.h>

#define GIF_W 32
#define GIF_H 32
#define GIF_FRAMES 12

// 'F18', 32x32px
const unsigned char epd_bitmap_F18 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F19', 32x32px
const unsigned char epd_bitmap_F19 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F20', 32x32px
const unsigned char epd_bitmap_F20 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F21', 32x32px
const unsigned char epd_bitmap_F21 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 
	0x03, 0xc0, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F22', 32x32px
const unsigned char epd_bitmap_F22 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F23', 32x32px
const unsigned char epd_bitmap_F23 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F24', 32x32px
const unsigned char epd_bitmap_F24 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F25', 32x32px
const unsigned char epd_bitmap_F25 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F26', 32x32px
const unsigned char epd_bitmap_F26 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F27', 32x32px
const unsigned char epd_bitmap_F27 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F1', 32x32px
const unsigned char epd_bitmap_F1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F28', 32x32px
const unsigned char epd_bitmap_F28 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 
	0x07, 0x80, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xee, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F2', 32x32px
const unsigned char epd_bitmap_F2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F3', 32x32px
const unsigned char epd_bitmap_F3 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F4', 32x32px
const unsigned char epd_bitmap_F4 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F5', 32x32px
const unsigned char epd_bitmap_F5 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 
	0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F6', 32x32px
const unsigned char epd_bitmap_F6 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0xf0, 
	0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x0d, 0x80, 
	0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x0e, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F7', 32x32px
const unsigned char epd_bitmap_F7 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0xf0, 0x00, 0x0f, 0xf1, 0xf0, 
	0x00, 0x0f, 0xe3, 0x60, 0x00, 0x0f, 0xc3, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F8', 32x32px
const unsigned char epd_bitmap_F8 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0xf0, 0x00, 0x0f, 0xfd, 0xf0, 
	0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0xf3, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F9', 32x32px
const unsigned char epd_bitmap_F9 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F10', 32x32px
const unsigned char epd_bitmap_F10 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F11', 32x32px
const unsigned char epd_bitmap_F11 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 
	0x00, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F12', 32x32px
const unsigned char epd_bitmap_F12 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 
	0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F13', 32x32px
const unsigned char epd_bitmap_F13 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 
	0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F14', 32x32px
const unsigned char epd_bitmap_F14 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F15', 32x32px
const unsigned char epd_bitmap_F15 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F16', 32x32px
const unsigned char epd_bitmap_F16 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 
	0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0f, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'F17', 32x32px
const unsigned char epd_bitmap_F17 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 
	0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xfe, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 
	0x00, 0x0f, 0xfd, 0x60, 0x00, 0x0f, 0xfb, 0x60, 0x00, 0x0f, 0x06, 0xc0, 0x00, 0x0f, 0x0d, 0x80, 
	0x00, 0x0f, 0x0d, 0x00, 0x00, 0x0f, 0x1f, 0x00, 0x00, 0x0f, 0x3e, 0x00, 0x00, 0x0f, 0x3c, 0x00, 
	0x00, 0x0f, 0x7c, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 
	0x00, 0x0f, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


const unsigned char* vortex_all_frames[] = {
	epd_bitmap_F1,
  epd_bitmap_F2,
  epd_bitmap_F3,
  epd_bitmap_F4,
  epd_bitmap_F5,
  epd_bitmap_F6,
  epd_bitmap_F7,
  epd_bitmap_F8,
  epd_bitmap_F9,
  epd_bitmap_F10,
  epd_bitmap_F11,
  epd_bitmap_F12,
  epd_bitmap_F13,
  epd_bitmap_F14,
  epd_bitmap_F15,
  epd_bitmap_F16,
  epd_bitmap_F17,
  epd_bitmap_F18,
  epd_bitmap_F19,
  epd_bitmap_F20,
  epd_bitmap_F21,
  epd_bitmap_F22,
  epd_bitmap_F23,
  epd_bitmap_F24,
  epd_bitmap_F25,
  epd_bitmap_F26,
  epd_bitmap_F27,
  epd_bitmap_F28,
};

const int frameCount = 28;


// ======================================================
// =================== CONFIGURATION ====================
// ======================================================

#define FLASH_SIGNATURE 0x45  // Increment to force reset for new features
#define RGB_PIN 12            // Data Pin for RGB
#define RGB_PWR_PIN 11        // Power Pin for RGB (Must be HIGH)
#define RGB_COUNT 1

// User Status LEDs (Active LOW)
#define LED_RED_PIN   17
#define LED_GREEN_PIN 16
#define LED_BLUE_PIN  25

// Pin Definitions
const int BTN_PINS[4] = { D7, D8, D9, D10 };
const int ENC_A  = D1;
const int ENC_B  = D0;
const int ENC_SW = D2;

// Timing
const unsigned long ENC_HOLD_TIME = 600; // ms
const unsigned long SPLASH_TIME = 2000;
const int MAX_TRAILS = 24;

// Internal codes for Media Keys (Mapped above standard ASCII range)
#define KEY_MEDIA_PLAY    0xF0
#define KEY_MEDIA_NEXT    0xF1
#define KEY_MEDIA_PREV    0xF2
#define KEY_MEDIA_VOL_UP  0xF3
#define KEY_MEDIA_VOL_DN  0xF4
#define KEY_MEDIA_MUTE    0xF5

// ======================================================
// ===================== STRUCTURES =====================
// ======================================================

struct ConfigData {
  uint8_t signature;
  uint8_t keyMapping[4];      // HID Codes
  uint8_t rgbMode;            // 0=Cycle, 1=Custom, 2=Off
  uint8_t rgbR, rgbG, rgbB;   // Custom colors
  uint8_t brightness;         // Global Brightness (0-255)
};

ConfigData config;

enum UiState {
  UI_SPLASH,
  UI_HOME,
  UI_SETTINGS_MAIN,
  UI_REMAP_WAIT_PRESS,
  UI_REMAP_SELECT_KEY,
  UI_RGB_MODE_SELECT,
  UI_RGB_CUSTOM_MENU,
  UI_RGB_CUSTOM_EDIT,
  UI_BRIGHTNESS
};

UiState uiState = UI_SPLASH;

// ======================================================
// =================== GLOBAL VARS ======================
// ======================================================

// RGB
Adafruit_NeoPixel rgb(RGB_COUNT, RGB_PIN, NEO_GRB + NEO_KHZ800);
uint8_t hueState = 0;

// Display
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// USB HID
uint8_t kb_report[8] = {0}; 
Adafruit_USBD_HID usb_hid;

// Encoder Inputs
bool encClick = false;
bool encHeldTriggered = false; 
bool encPressedState = false;
unsigned long encPressTime = 0;

volatile int encoderPos = 0;
int lastEncoderPos = 0;
int encDir = 0; // -1, 0, 1

// UI Variables
int menuIndex = 0;
int remapTargetBtn = -1;
int remapKeyIndex = 0;
int rgbColorTarget = 0; // 0=R, 1=G, 2=B

// Home Screen Logic
unsigned long lastActivity = 0;
int lastDirIcon = 0;
unsigned long keyTimes[32];
uint8_t keyTimeIdx = 0;

struct Trail {
  bool active;
  int x;
  int y;
  int h;        // Height of the trail
  int btnIndex; // The button this trail belongs to
  bool held;    // Whether the button is still being held
};

Trail trails[MAX_TRAILS];

struct ButtonState {
  bool pressed;
  bool justPressed;
};
ButtonState btnState[4];

// ======================================================
// ==================== KEY TABLES ======================
// ======================================================

struct KeyDef {
  const char* label;
  uint8_t code;
};

const KeyDef keyList[] = {
  // Numbers
  {"0", HID_KEY_0}, {"1", HID_KEY_1}, {"2", HID_KEY_2}, {"3", HID_KEY_3}, {"4", HID_KEY_4},
  {"5", HID_KEY_5}, {"6", HID_KEY_6}, {"7", HID_KEY_7}, {"8", HID_KEY_8}, {"9", HID_KEY_9},
  // Letters
  {"A", HID_KEY_A}, {"B", HID_KEY_B}, {"C", HID_KEY_C}, {"D", HID_KEY_D}, {"E", HID_KEY_E},
  {"F", HID_KEY_F}, {"G", HID_KEY_G}, {"H", HID_KEY_H}, {"I", HID_KEY_I}, {"J", HID_KEY_J},
  {"K", HID_KEY_K}, {"L", HID_KEY_L}, {"M", HID_KEY_M}, {"N", HID_KEY_N}, {"O", HID_KEY_O},
  {"P", HID_KEY_P}, {"Q", HID_KEY_Q}, {"R", HID_KEY_R}, {"S", HID_KEY_S}, {"T", HID_KEY_T},
  {"U", HID_KEY_U}, {"V", HID_KEY_V}, {"W", HID_KEY_W}, {"X", HID_KEY_X}, {"Y", HID_KEY_Y}, {"Z", HID_KEY_Z},
  // Media Keys (New)
  {"PLAY", KEY_MEDIA_PLAY}, {"NEXT", KEY_MEDIA_NEXT}, {"PREV", KEY_MEDIA_PREV},
  {"VOL+", KEY_MEDIA_VOL_UP}, {"VOL-", KEY_MEDIA_VOL_DN}, {"MUTE", KEY_MEDIA_MUTE},
  // Symbols
  {";", HID_KEY_SEMICOLON}, {"=", HID_KEY_EQUAL}, {",", HID_KEY_COMMA}, {"-", HID_KEY_MINUS},
  {".", HID_KEY_PERIOD}, {"/", HID_KEY_SLASH}, {"`", HID_KEY_GRAVE}, {"[", HID_KEY_BRACKET_LEFT},
  {"]", HID_KEY_BRACKET_RIGHT}, {"'", HID_KEY_APOSTROPHE}, {"\\", HID_KEY_BACKSLASH},
  // Functions
  {"F1", HID_KEY_F1}, {"F2", HID_KEY_F2}, {"F3", HID_KEY_F3}, {"F4", HID_KEY_F4},
  {"F5", HID_KEY_F5}, {"F6", HID_KEY_F6}, {"F7", HID_KEY_F7}, {"F8", HID_KEY_F8},
  {"F9", HID_KEY_F9}, {"F10", HID_KEY_F10}, {"F11", HID_KEY_F11}, {"F12", HID_KEY_F12},
  // Special
  {"ESC", HID_KEY_ESCAPE}, {"TAB", HID_KEY_TAB}, {"ENT", HID_KEY_ENTER}, {"SPC", HID_KEY_SPACE},
  {"BSP", HID_KEY_BACKSPACE}, {"DEL", HID_KEY_DELETE}, 
  {"UP", HID_KEY_ARROW_UP}, {"DN", HID_KEY_ARROW_DOWN}, {"LF", HID_KEY_ARROW_LEFT}, {"RT", HID_KEY_ARROW_RIGHT},
  {"CAPS", HID_KEY_CAPS_LOCK}, {"PRT", HID_KEY_PRINT_SCREEN},
  {"LCTL", HID_KEY_CONTROL_LEFT}, {"LSFT", HID_KEY_SHIFT_LEFT}, {"LALT", HID_KEY_ALT_LEFT}, {"LGUI", HID_KEY_GUI_LEFT}
};
const int KEY_LIST_LEN = sizeof(keyList) / sizeof(keyList[0]);

const char* getLabel(uint8_t code) {
  for(int i=0; i<KEY_LIST_LEN; i++) {
    if(keyList[i].code == code) return keyList[i].label;
  }
  return "?";
}

// ======================================================
// ======================= LOGO =========================
// ======================================================
const unsigned char epd_bitmap_vortex_no_text [] PROGMEM = {
  0xf0,0x00,0x00,0xe0,0x00,0x00,0xe0,0x00,0x00,0x1d,0x80,0x00,
  0x1d,0x80,0x00,0x1d,0xbe,0x60,0x01,0xbe,0xa0,0x01,0xbd,0x00,
  0x01,0x80,0x40,0x01,0x82,0x80,0x01,0x85,0x00,0x01,0x8e,0x00,
  0x01,0x8e,0x00,0x01,0x9c,0x00,0x01,0xb8,0x00,0x01,0xf8,0x00,
  0x01,0xf0,0x00,0x01,0xe0,0x00,0x01,0xc0,0x00,0x01,0xc0,0x00
};
#define LOGO_W 20
#define LOGO_H 20

static inline uint8_t bitrev(uint8_t b){
  b = (b >> 4) | (b << 4);
  b = ((b & 0xCC) >> 2) | ((b & 0x33) << 2);
  b = ((b & 0xAA) >> 1) | ((b & 0x55) << 1);
  return b;
}
void drawBitmap(int x, int y, const uint8_t* src) {
  uint8_t buf[60]; 
  for(int i=0; i<60; i++) buf[i] = bitrev(pgm_read_byte(&src[i]));
  u8g2.drawXBMP(x, y, LOGO_W, LOGO_H, buf);
}

void drawLogoBitmap(int x, int y, const uint8_t* src) {
  uint8_t buf[128]; 
  for(int i=0; i<128; i++) buf[i] = bitrev(pgm_read_byte(&src[i]));
  u8g2.drawXBMP(x, y, 32, 32, buf);
}


// ======================================================
// ===================== SAVE/LOAD ======================
// ======================================================
void saveConfig() {
  EEPROM.put(0, config);
  EEPROM.commit();
}
void loadConfig() {
  EEPROM.begin(256);
  EEPROM.get(0, config);
  if (config.signature != FLASH_SIGNATURE) {
    config.signature = FLASH_SIGNATURE;
    config.keyMapping[0] = HID_KEY_A;
    config.keyMapping[1] = HID_KEY_S;
    config.keyMapping[2] = HID_KEY_L;
    config.keyMapping[3] = HID_KEY_SEMICOLON;
    config.rgbMode = 0; 
    config.rgbR = 0; config.rgbG = 255; config.rgbB = 255;
    config.brightness = 150;
    saveConfig();
  }
}

// ======================================================
// ==================== USB / HID =======================
// ======================================================

uint8_t const hid_report_descriptor[] = {
  TUD_HID_REPORT_DESC_KEYBOARD(HID_REPORT_ID(1)),
  TUD_HID_REPORT_DESC_CONSUMER(HID_REPORT_ID(2))
};

void setupHID() {
  usb_hid.setPollInterval(2);
  usb_hid.setReportDescriptor(hid_report_descriptor, sizeof(hid_report_descriptor));
  usb_hid.begin();
}

void sendMediaRaw(uint16_t key) {
  if (!usb_hid.ready()) return;
  usb_hid.sendReport(2, &key, 2);
}

// Modified HID Update to handle Keyboard AND Media keys simultaneously
void updateHID() {
  if (!usb_hid.ready()) return;

  // 1. Create a fresh, empty keyboard report
  // Byte 0: Modifiers, Byte 1: Reserved, Bytes 2-7: Keycodes
  uint8_t current_kb_report[8] = {0, 0, 0, 0, 0, 0, 0, 0}; 
  uint16_t media_usage = 0;
  int kb_slot = 2; 

  // 2. Scan physical button states
  for(int i = 0; i < 4; i++) {
    if (btnState[i].pressed) {
      uint8_t code = config.keyMapping[i];
      
      // Separate Media Keys from Keyboard Keys
      if (code >= 0xF0) {
        if (code == KEY_MEDIA_PLAY)   media_usage = HID_USAGE_CONSUMER_PLAY_PAUSE;
        if (code == KEY_MEDIA_NEXT)   media_usage = HID_USAGE_CONSUMER_SCAN_NEXT_TRACK;
        if (code == KEY_MEDIA_PREV)   media_usage = HID_USAGE_CONSUMER_SCAN_PREVIOUS_TRACK;
        if (code == KEY_MEDIA_VOL_UP) media_usage = HID_USAGE_CONSUMER_VOLUME_INCREMENT;
        if (code == KEY_MEDIA_VOL_DN) media_usage = HID_USAGE_CONSUMER_VOLUME_DECREMENT;
        if (code == KEY_MEDIA_MUTE)   media_usage = HID_USAGE_CONSUMER_MUTE;
      } 
      else {
        // Standard Key: Place in the next available HID slot (up to 6 keys total)
        if (kb_slot < 8) {
          current_kb_report[kb_slot] = code;
          kb_slot++;
        }
      }
    }
  }

  // 3. Compare with the LAST sent report to prevent USB flooding
  // Only send if the state has actually changed
  static uint8_t last_kb_report[8] = {0};
  if (memcmp(current_kb_report, last_kb_report, 8) != 0) {
    usb_hid.sendReport(1, current_kb_report, 8);
    memcpy(last_kb_report, current_kb_report, 8);
  }
  
  // 4. Handle Media Keys (Consumer Report)
  static uint16_t last_media_usage = 0;
  if (media_usage != last_media_usage) {
    usb_hid.sendReport(2, &media_usage, 2);
    last_media_usage = media_usage;
  }
}

// ======================================================
// ================== STATUS LEDS =======================
// ======================================================
void updateStatusLED() {
  // Reset all to OFF (HIGH)
  digitalWrite(LED_RED_PIN, HIGH);
  digitalWrite(LED_GREEN_PIN, HIGH);
  digitalWrite(LED_BLUE_PIN, HIGH);

  if (uiState != UI_HOME && uiState != UI_SPLASH) {
    // Blue: Settings Mode
    digitalWrite(LED_BLUE_PIN, LOW);
  } else if (!TinyUSBDevice.mounted()) {
    // Red: Disconnected
    digitalWrite(LED_RED_PIN, LOW);
  } else {
    // Green: Connected & Home
    digitalWrite(LED_GREEN_PIN, LOW);
  }
}

// ======================================================
// ===================== RGB LOGIC ======================
// ======================================================

void updateRGB() {
  rgb.setBrightness(config.brightness);
  
  if (config.rgbMode == 2) { // OFF
    rgb.clear();
  } 
  else if (config.rgbMode == 0) { // CYCLE
    rgb.setPixelColor(0, rgb.ColorHSV(hueState++ * 256));
    if (hueState > 255) hueState = 0;
  } 
  else if (config.rgbMode == 1) { // CUSTOM
    rgb.setPixelColor(0, rgb.Color(config.rgbR, config.rgbG, config.rgbB));
  }
  rgb.show();
}

// ======================================================
// ===================== INPUTS =========================
// ======================================================

void encoderISR() {
  uint8_t state = (digitalRead(ENC_A) << 1) | digitalRead(ENC_B);
  static uint8_t oldState = 0;
  static const int8_t tbl[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};
  encoderPos -= tbl[(oldState << 2) | state];
  oldState = state;
}

void readInputs() {
  // 1. Encoder Button
  bool sw = !digitalRead(ENC_SW);
  unsigned long now = millis();

  if (sw) { // Button is DOWN
    if (!encPressedState) {
      encPressedState = true;
      encPressTime = now;
      encHeldTriggered = false; 
    } else {
      if (!encHeldTriggered && (now - encPressTime > ENC_HOLD_TIME)) {
        encHeldTriggered = true; 
        
        // Hold Action
        if (uiState == UI_HOME) {
          uiState = UI_SETTINGS_MAIN;
          menuIndex = 0;
        } else if (uiState != UI_SPLASH) {
          uiState = UI_HOME; // Exit settings
        }
      }
    }
  } else { // Button is UP
    if (encPressedState) {
      encPressedState = false;
      if (!encHeldTriggered) {
        encClick = true;
      }
    }
  }

  // 2. Encoder Rotation
  int newPos = encoderPos / 4; 
  encDir = 0;
  if (newPos != lastEncoderPos) {
    encDir = (newPos > lastEncoderPos) ? 1 : -1;
    lastEncoderPos = newPos;
    
    // Global Volume Control (Only on Home)
    if (uiState == UI_HOME) {
      uint16_t v = encDir > 0 ? HID_USAGE_CONSUMER_VOLUME_INCREMENT : HID_USAGE_CONSUMER_VOLUME_DECREMENT;
      usb_hid.sendReport(2, &v, 2);
      delay(5);
      uint16_t z = 0;
      usb_hid.sendReport(2, &z, 2);

      lastActivity = now;
      lastDirIcon = encDir;
    }
  }

  // 3. Keys
  for(int i=0; i<4; i++) {
    bool p = !digitalRead(BTN_PINS[i]);
    btnState[i].justPressed = (p && !btnState[i].pressed);
    btnState[i].pressed = p;

    // KPS Logic
    if (btnState[i].justPressed && uiState == UI_HOME) {
      keyTimes[keyTimeIdx++ % 32] = millis();
      for(int t=0; t<MAX_TRAILS; t++) {
        if(!trails[t].active) {
          // {active, x, y, h, btnIndex, held}
          // Start at y=46 with height h=2
          trails[t] = {true, 48 + (i*20), 46, 2, i, true};
          break;
        }
      }
    }
  }
}

// ======================================================
// ======================= LOGIC ========================
// ======================================================

float getKPS() {
  unsigned long now = millis();
  int count = 0;
  for(int i=0; i<32; i++) {
    if (now - keyTimes[i] < 1000) count++;
  }
  return (float)count;
}

void scroll(int &val, int min, int max, int dir) {
  if (dir == 0) return;
  val += dir;
  if (val > max) val = min;
  if (val < min) val = max;
}

void handleStateMachine() {
  // Navigation Inversion: 
  // Clockwise (+1) becomes -1 (Up in lists)
  // Counter-Clockwise (-1) becomes +1 (Down in lists)
  int menuDir = -encDir; 

  switch (uiState) {
    case UI_HOME:
      if (encClick) {
        uint16_t pp = HID_USAGE_CONSUMER_PLAY_PAUSE;
        usb_hid.sendReport(2, &pp, 2);
        delay(5);
        uint16_t z = 0;
        usb_hid.sendReport(2, &z, 2);
        encClick = false;
      }
      
      // // STRICT STATE SYNC (Anti-Ghosting Fix)
      // if (usb_hid.ready()) {
      //   uint8_t current_kb_report[8] = {0, 0, 0, 0, 0, 0, 0, 0}; 
      //   uint16_t media_usage = 0;
      //   int kb_slot = 2; 

      //   for(int i = 0; i < 4; i++) {
      //     if (btnState[i].pressed) {
      //       uint8_t code = config.keyMapping[i];
      //       if (code >= 0xF0) { // Media Keys
      //         if (code == KEY_MEDIA_PLAY)   media_usage = HID_USAGE_CONSUMER_PLAY_PAUSE;
      //         if (code == KEY_MEDIA_NEXT)   media_usage = HID_USAGE_CONSUMER_SCAN_NEXT_TRACK;
      //         if (code == KEY_MEDIA_PREV)   media_usage = HID_USAGE_CONSUMER_SCAN_PREVIOUS_TRACK;
      //         if (code == KEY_MEDIA_VOL_UP) media_usage = HID_USAGE_CONSUMER_VOLUME_INCREMENT;
      //         if (code == KEY_MEDIA_VOL_DN) media_usage = HID_USAGE_CONSUMER_VOLUME_DECREMENT;
      //         if (code == KEY_MEDIA_MUTE)   media_usage = HID_USAGE_CONSUMER_MUTE;
      //       } else if (kb_slot < 8) { // Standard Keys
      //         current_kb_report[kb_slot++] = code;
      //       }
      //     }
      //   }

      //   static uint8_t last_kb_report[8] = {0};
      //   if (memcmp(current_kb_report, last_kb_report, 8) != 0) {
      //     usb_hid.sendReport(1, current_kb_report, 8);
      //     memcpy(last_kb_report, current_kb_report, 8);
      //   }
        
      //   static uint16_t last_media_usage = 0;
      //   if (media_usage != last_media_usage) {
      //     usb_hid.sendReport(2, &media_usage, 2);
      //     last_media_usage = media_usage;
      //   }
      // }
      break;

    case UI_SETTINGS_MAIN:
      scroll(menuIndex, 0, 2, menuDir); 
      if (encClick) {
        encClick = false;
        if (menuIndex == 0) uiState = UI_REMAP_WAIT_PRESS;
        else if (menuIndex == 1) { uiState = UI_RGB_MODE_SELECT; menuIndex = config.rgbMode; }
        else if (menuIndex == 2) uiState = UI_BRIGHTNESS;
      }
      break;

    case UI_REMAP_WAIT_PRESS:
      for(int i=0; i<4; i++) {
        if(btnState[i].justPressed) {
          remapTargetBtn = i;
          uiState = UI_REMAP_SELECT_KEY;
          remapKeyIndex = 0;
          break;
        }
      }
      if (encClick) { encClick=false; uiState = UI_SETTINGS_MAIN; }
      break;

    case UI_REMAP_SELECT_KEY:
      // INVERTED: Clockwise now moves UP through the key list
      scroll(remapKeyIndex, 0, KEY_LIST_LEN-1, menuDir); 
      if (encClick) {
        encClick = false;
        config.keyMapping[remapTargetBtn] = keyList[remapKeyIndex].code;
        saveConfig();
        uiState = UI_SETTINGS_MAIN;
      }
      break;

    case UI_RGB_MODE_SELECT:
      scroll(menuIndex, 0, 2, menuDir); 
      if (encClick) {
        encClick = false;
        config.rgbMode = menuIndex;
        saveConfig();
        if (config.rgbMode == 1) { 
          uiState = UI_RGB_CUSTOM_MENU;
          rgbColorTarget = 0;
        } else {
          uiState = UI_SETTINGS_MAIN;
        }
      }
      break;

    case UI_RGB_CUSTOM_MENU:
      scroll(rgbColorTarget, 0, 2, menuDir); 
      if (encClick) {
        encClick = false;
        uiState = UI_RGB_CUSTOM_EDIT;
      }
      break;

    case UI_RGB_CUSTOM_EDIT:
      // Keep encDir: CW = Increase color value
      if (encDir != 0) {
        int val = (rgbColorTarget==0)?config.rgbR : (rgbColorTarget==1)?config.rgbG : config.rgbB;
        val = constrain(val + (encDir * 5), 0, 255);
        if (rgbColorTarget == 0) config.rgbR = val;
        if (rgbColorTarget == 1) config.rgbG = val;
        if (rgbColorTarget == 2) config.rgbB = val;
        updateRGB();
      }
      if (encClick) {
        encClick = false;
        saveConfig();
        uiState = UI_RGB_CUSTOM_MENU;
      }
      break;
    
    case UI_BRIGHTNESS:
      // Keep encDir: CW = Brighter
      if (encDir != 0) {
        int b = config.brightness + (encDir * 5);
        config.brightness = constrain(b, 5, 255);
        updateRGB(); 
      }
      if (encClick) {
        encClick = false;
        saveConfig();
        uiState = UI_SETTINGS_MAIN;
      }
      break;
  }
}
// ======================================================
// ==================== DRAWING =========================
// ======================================================

void drawDetailPanel() {
  drawBitmap(10, 0, epd_bitmap_vortex_no_text); 

  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(12, 35); u8g2.print("KPS");
  u8g2.setFont(u8g2_font_profont17_tf);
  u8g2.setCursor(12, 50); u8g2.print((int)getKPS());

  if (millis() - lastActivity < 1000) {
     u8g2.setFont(u8g2_font_ncenB18_tr);
     u8g2.setCursor(12, 64);
     u8g2.print(lastDirIcon > 0 ? "+" : "-");
  }
  
  u8g2.drawVLine(40, 0, 64);
}

void drawTrails() {
  for(int i=0; i<MAX_TRAILS; i++) {
    if (!trails[i].active) continue;
    
    u8g2.drawBox(trails[i].x, trails[i].y, 16, trails[i].h);
    
    if (!trails[i].held) {
      // Falling/Floating away logic
      trails[i].y -= 3; // Speed it up slightly
      if (trails[i].y + trails[i].h < 0) trails[i].active = false;
    } else {
      // Check if button was released
      if (!btnState[trails[i].btnIndex].pressed) {
        trails[i].held = false;
      } else {
        // Grow logic while held
        if (trails[i].h < 40) { // Increased max height to 40
             trails[i].h += 3; // Grow 3x faster than before
             trails[i].y -= 3; // Move top up to match growth
        }
      }
    }
  }
}

void drawHome() {
  drawDetailPanel();
  drawTrails();

  u8g2.setFont(u8g2_font_profont12_tf);
  for(int i=0; i<4; i++) {
    int x = 48 + (i * 20);
    int y = 48;
    if (btnState[i].pressed) u8g2.drawBox(x, y, 16, 16);
    else u8g2.drawFrame(x, y, 16, 16);

    u8g2.setCursor(x + 5, y + 11);
    if (btnState[i].pressed) u8g2.setDrawColor(0);
    u8g2.print(getLabel(config.keyMapping[i]));
    u8g2.setDrawColor(1);
  }
}

void drawSettings() {
  u8g2.setFont(u8g2_font_profont12_tf);
  
  // Logo Top Left
  drawBitmap(0, 0, epd_bitmap_vortex_no_text); 
  
  u8g2.setCursor(30, 15); 
  u8g2.print("SETTINGS");
  u8g2.drawHLine(0, 22, 128);

  int yStart = 35;
  const char* items[] = {"Remap Buttons", "RGB Settings", "Brightness"};
  
  for(int i=0; i<3; i++) {
    if (i == menuIndex) {
      u8g2.drawBox(0, yStart + (i*12) - 9, 100, 11);
      u8g2.setDrawColor(0);
    }
    u8g2.setCursor(5, yStart + (i*12));
    u8g2.print(items[i]);
    u8g2.setDrawColor(1);
  }
}

void drawRemap() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(10, 15);
  if (uiState == UI_REMAP_WAIT_PRESS) {
    u8g2.print("Press key to remap"); // Text Changed
  } else {
    u8g2.print("Select Key:");
    u8g2.setFont(u8g2_font_ncenB14_tr);
    u8g2.setCursor(50, 45);
    u8g2.print(keyList[remapKeyIndex].label);
    
    u8g2.setFont(u8g2_font_profont10_tf);
    int prev = (remapKeyIndex - 1 + KEY_LIST_LEN) % KEY_LIST_LEN;
    int next = (remapKeyIndex + 1) % KEY_LIST_LEN;
    u8g2.setCursor(50, 25); u8g2.print(keyList[prev].label);
    u8g2.setCursor(50, 60); u8g2.print(keyList[next].label);
  }
}

void drawRGBCustom() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(5, 12); u8g2.print("RGB CUSTOM");
  
  int bars[3] = {config.rgbR, config.rgbG, config.rgbB};
  const char* lbls[3] = {"R", "G", "B"};
  
  for(int i=0; i<3; i++) {
    int y = 28 + (i*12);
    u8g2.setCursor(5, y); u8g2.print(lbls[i]);
    u8g2.setCursor(20, y); u8g2.print(bars[i]);

    u8g2.drawFrame(45, y-8, 80, 8);
    int w = map(bars[i], 0, 255, 0, 78);
    u8g2.drawBox(46, y-7, w, 6);

    if (i == rgbColorTarget) {
      u8g2.setCursor(128, y);
      if (uiState == UI_RGB_CUSTOM_EDIT) u8g2.drawStr(120, y, "<");
      else u8g2.drawStr(120, y, "*");
    }
  }
}

void drawBrightness() {
  u8g2.setFont(u8g2_font_profont12_tf);
  u8g2.setCursor(10, 20); u8g2.print("BRIGHTNESS");
  
  u8g2.setCursor(10, 40); u8g2.print(config.brightness);
  
  u8g2.drawFrame(40, 32, 80, 10);
  int w = map(config.brightness, 0, 255, 0, 78);
  u8g2.drawBox(41, 33, w, 8);
}

void drawSplash() {
  static int currentFrame = 0;
  static unsigned long lastFrameTime = 0;
  static unsigned long splashStartTime = 0;
  unsigned long now = millis();

  if (splashStartTime == 0) splashStartTime = now;

  const uint8_t* framePtr = vortex_all_frames[currentFrame];

  u8g2.clearBuffer();
  
  // Use the updated function with 32x32 dimensions
  drawLogoBitmap(48, 16, framePtr);
  
  u8g2.sendBuffer();
  if (now - lastFrameTime >= 40) {
      // Only increment if we haven't reached the last frame (frameCount - 1)
      if (currentFrame < frameCount - 1) {
        currentFrame++;
      }
      lastFrameTime = now;
    }

  if (now - splashStartTime > 2500) {
    uiState = UI_HOME;
    currentFrame = 0;
    splashStartTime = 0;
  }
}
// ======================================================
// ==================== MAIN LOOP =======================
// ======================================================

void setup() {
  for(int i=0; i<4; i++) pinMode(BTN_PINS[i], INPUT_PULLUP);
  pinMode(ENC_A, INPUT_PULLUP);
  pinMode(ENC_B, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);
  
  // Status LEDs (Active Low)
  pinMode(LED_RED_PIN, OUTPUT);
  pinMode(LED_GREEN_PIN, OUTPUT);
  pinMode(LED_BLUE_PIN, OUTPUT);
  digitalWrite(LED_RED_PIN, HIGH);
  digitalWrite(LED_GREEN_PIN, HIGH);
  digitalWrite(LED_BLUE_PIN, HIGH);
  
  attachInterrupt(digitalPinToInterrupt(ENC_A), encoderISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_B), encoderISR, CHANGE);

  // RGB POWER FIX
  pinMode(RGB_PWR_PIN, OUTPUT);
  digitalWrite(RGB_PWR_PIN, HIGH);

  rgb.begin();
  
  loadConfig();
  rgb.setBrightness(config.brightness);
  
  setupHID();

  u8g2.begin();
}

void loop() {
  readInputs();
  handleStateMachine();
  updateRGB(); 
  updateStatusLED();
  updateHID();

  if (uiState == UI_SPLASH) {
    drawSplash();
    return;
  }

  u8g2.clearBuffer();
  
  switch(uiState) {
    case UI_HOME:            drawHome(); break;
    case UI_SETTINGS_MAIN:   drawSettings(); break;
    case UI_REMAP_WAIT_PRESS:
    case UI_REMAP_SELECT_KEY:drawRemap(); break;
    case UI_RGB_MODE_SELECT: 
      u8g2.setFont(u8g2_font_profont12_tf);
      u8g2.setCursor(10, 20); u8g2.print("RGB MODE:");
      u8g2.setFont(u8g2_font_ncenB14_tr);
      u8g2.setCursor(20, 45); 
      if(menuIndex==0) u8g2.print("CYCLE");
      if(menuIndex==1) u8g2.print("CUSTOM");
      if(menuIndex==2) u8g2.print("OFF");
      break;
    case UI_RGB_CUSTOM_MENU:
    case UI_RGB_CUSTOM_EDIT: drawRGBCustom(); break;
    case UI_BRIGHTNESS:      drawBrightness(); break;
  }
  
  u8g2.sendBuffer();
}